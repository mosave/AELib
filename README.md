# AE' ESP8266 IoT Framework

## Набор базовых модулей для упрощения и ускорения разработки IoT устройств на основе процессоров ESP82XX

Фреймворк позволяет быстро разрабатывать кастомные прошивки IoT устройств в MQTT инфраструктуре и реализует все необходимые для этого базовые функции:
 * Менеджер EEPROM с автоматической отложенной записью изменений
 * Поддержание постоянного соединения к WiFi сети и MQTT брокеру с восстановлением при сбоях.
 * Возможность поиска и перебороа MQTT брокеров в локальной сети (наличии mDNS).
 * Интеграция в MQTT инфраструктуру: публикация информации об состоянии и heartbeat устройства, обработка основных команд настройки и управления через MQTT
 * Контроль активности сервера Home Assistant и поддержка "управляемого" режима позволяет изменять логику работы устройства при недоступности HA.
 * Синхронизация времени (требует доступа в internet либо локального NNTP сервера)
 * Поддержка OTA (On The Air update, прошивка устройства по WiFi)
 * Модуль обработки кнопок: защита от дребезга, различные режимы работы и типы событий: нажатие/отпускание, короткие/длинные/множественные нажатия кнопок и комбинаций кнопок
 * Модуль управления реле: ограничение частоты переключений, разнесение по времени пусковых токов
 * Диммер: одноканальный, двухканальный и WC/WW режим работы
 * Готовые модули поддержки сенсоров и устройств (DHT22, BMP280, BH1750...), требуется установка сторонних библиотек.

## Примеры использования фреймворка

### Простая базовая прошивка 3х-канального смарт реле

В репозитории можно найти пример проекта для Arduino Studio (файл AELib.ino), 
реализующий прошивку типичного смарт реле. Такое реле, например, можно использовать для управления тремя 
группами освещения в комнате с помощью двухклавишного выключателя.

В прошивке предполагается что ESP управляет тремя реле, подключенными к выходам D5, D6 и D7 (GPIO14, 12 и 13 соответственно) 
и имеет 2 нормально разомкнутые кнопки без фиксации, подключенные к D1 и D2 (GPIO 5 и 4) и GND.

Нажатия кнопок управляют первым и вторым реле, одновременное нажатие двух кнопок - третьим реле.

Встроенный светодиод отображает состояние подключения к WiFi/MQTT и нажатия кнопок.

### Другие примеры использования
 * [MQTT интерфейс электросчетчика Eastron SDM630](https://github.com/mosave/SDM630Gateway)
 * [Замена модуля Broadlink в термостатах Beok на MQTT контроллер на базе ESP8266](https://github.com/mosave/Beok2MQTT)

## Модули и файлы фреймовка

### Config.h: Конфигурация прошивки

Файл включается во все модули библиотеки, позволяя напрямую задавать настройки модулей с помощью #define.
При создании нового проекта используйти файл [Config.h](AELib/Config.h) из репозитория в качестве шаблона.

Необходимо определить как минимум две основные константы: **WIFI_SSID** и **WIFI_Password**.
Все остальные настройки модулей фреймворка описаны в [Config.h](AELib/Config.h) и не являются обязательными.

Настройка анонсирования MQTT брокера через mDNS [описана здесь](mDNS/readme.md)

### AELib.h: Поддержка модульной архитектуры и хранение данных в EEPROM

Помимо функций поддержки модульной архитектуры в библиотеке реализовано сохранение зарегистрированны блоков памяти и ихEEPROM. 
При этом необходимо учитывать что объем EEPROM для ESP8266 составляет всего 4096 байт и часть памяти уже зарезервирована:

 * 96 байт используется для хранения настроек WiFi и MQTT. Модуль Comms, идентификатор блока памяти 0x43 ('C').
 * 128 байт используется модулем Relays, идентификатор блока памяти 0x52 ('R').
 * 8 байт используется для хранения пороговых значений для восхода и заката. Модуль LightMeters при инициализации с параметром (true), идентификатор блока памяти 0x4C ('L').

Основные функции:

* **aeInit()**: Инициализация библиотеки. Должна вызывается в функции setup() одной из первых.
* **aeRegisterLoop( LOOP loop )**: Регистрация loop-функций модулей. Все loop-функции исполняются при вызове aeLoop() в порядке регистрации.
* **aeLoop()**: Исполнить loop-функции модулей в порядке их регистрации. aeLoop() должен вызываться в основном loop().
* **storageRegisterBlock(...)**: регистрация блока памяти для его сохранения в EEPROM
* **storageSave()**: Сохранение изменившихся зарегистрированных блоков памяти в EEPROM. Используйте storageSave() в случае если изменения требут немедленного сохранения либо предполагается скорая перезагрузка устройства. По умолчанию EEPROM переписывается не чаще одного раза в час.
* **storageReset()**: Инициализация всех зарегистрированных блоков памяти нулями.

Модуль так же определяет макросы aePrint(...) / aePrintf(...) / aePrintln(...) через соответствующие вызовы вывода текста в 
последовательный порт (Serial.Print(...) / Serial.Printf(...) / Serial.Println(...) соответственно), поэтому в случае если UART 
интерфейс устройства занят - переопределите эти функции на пустые в конфиге (см. config.h)

### Comms: WiFi, MQTT и OTA

Основной модуль фреймворка. Установление и поддержание соединения WiFi, регистрация на MQTT брокере, hertbeat и взаимодействие с Home Assistant,
обновление прошивки по воздуху и тд. Требует установки библиотеки [PubSubClient by Nick O'Leary](https://github.com/knolleary/pubsubclient)

Модуль автоматически публикует следующие топики в поддереве устройства (см. **MQTT_Root**):
 * **DeviceInfo**: Информация об устройстве: MAC и IP адрес, тип контроллера, объем памятя, версия прошивки и тд. (retained).
 * **Online**: "1" / "0". Значение "1" перепосылается каждые 10 минут (heartbeat), 
 "0" выставляется MQTT брокером при пропадении устройства из сети (т.н. Last Will). (retained)
 * **Activity**: "1"  "0". Выставляется в "1" при обнаружении активности: нажатие на кнопку либо при вызове метода **triggerActivity()**.

Модуль получает и исполняет следующие команды, полученные через MQTT:
 * **SetName**, payload = "hostname": переименование устройства. Исполняется только если не определена константа WIFI_HostName
 * **SetRoot**, payload = "MQTT root": изменение корневого топика устройства. Исполняется только если не определена константа MQTT_Root
 * **EnableOTA**: включение режима перепрошивки по воздуху. Требуется введения WiFi пароля. Устройство будет перезагружено, если в течение 15 минут не получит запрос на перепрошивку.
 * **Reset**: перезагрузка устройства.
 * **FactoryReset**: Сброс значений в EEPROM и перезагрузка.

Если в config.h определена временная зона (**TIMEZONE**) - модуль автоматически синхронизирует локальное время c локальным ntp сервером
(если он анонсируется в сети через mDNS) либо с "time.google.com" / "time.nist.gov".
Пример получения локального времени в коде программы:
```
time_t currentTime = time(nullptr);
if( currentTime > 10000 ) {
  tm* lt = localtime(&currentTime);
  printf("%02d:%02d", lt->tm_hour, lt->tm_min);
}

```


### Buttons: обработка "кнопочных" входов с защитой от дребезга и поддержкой виртуальных кнопок

Модуль Buttons поддерживает два режима обработки кнопок.
В режиме по умолчанию события **ShortPressed()**, **LongPressed()** и **VeryLongPressed()** возникают только после отпускания кнопки.
В "простом" режиме событие **LongPressed()** возвращается при нажатии и удержании кнопки не менее одной секунды, 
а событие **VeryLongPressed()** становится недоступно. Для компиляции в "простом" режиме в Config.h необходимо прописать

**#define ButtonsEasyMode**
                           
Функции, возвращающие состояние и события кнопок:
 * **btnState()**: текущее состояние кнопки, нажата или отжата
 * **btnPressed()**, **btnReleased()**: обнаружено нажатие либо отпускание кнопки. Сбрасывается при считывании
 * **btnShortPressed()**: обнаружено короткое нажатие кнопки. Сбрасывается при считывании
 * **btnLongPressed()**: Обнаружено длинное нажатие кнопки. Сбрасывается при считывании
 * **btnVeryLongPressed()**: Обнаружено очень длинное (более 10с) нажатие кнопки. Сбрасывается при считывании

 Кроме того, на "10 быстрых нажатий" любой кнопки можно навесить одно из предопределенных 
 действий: перезагрузить устройство, сбросить настройки, выкючить WiFi и тд.

Состояние именованных кнопок публикуется в MQTT в поддереве устройства:
 * **\<Button\>/State**: "1" или "0", текущее состояние кнопки (retained)
 * **\<Button\>/ShortPressed**: отправляется однократно при обнаружении короткого нажатия
 * **\<Button\>/LongPressed**: отправляется однократно при обнаружении длинного нажатия
 * **\<Button\>/VeryLongPressed**: отправляется однократно при обнаружении очень длинного (более 10с) нажатия



### Relays: управление исполнительными выходами

Если при регистрации реле в качестве имени передано NULL или пустая строка, то ему получит имя в 
формате "Relay\<N\>" и в дальнейшем может быть переименовано по MQTT.

Модуль публикует состояние кнопок в MQTT в поддереве устройства:
 * **\<RelayName\>/State**: "1" или "0", Текущее состояние реле (retained). При запуске реле по умолчанию всегда выключено.
   Значение по умолчанию можно изменить в прошивке а хранение предыдущего значения можно реализовать средствами MQTT, 
   установив отправив топик SetState с флагом retained.
 
Топики, обрабатываемые модулем: 
 * **\<RelayName\>/SetState**, payload "1" или "0": задать текущее состояние реле
 * **\<RelayName\>/Switch**: переключить реле в другое состояние
 * **\<RelayName\>/SetName**, payload = "New Relay Name": переименовать реле, если оно не было жестко определено при регистрации

### LED: управление светодиодом

Реализация нескольких светодиодных эффектов на встроенном или подключенном GPIO светодиоде.
В конфиге необходимо определить константу LED_Pin.

Поддерживаемые эффекты:
 * On, Off, Standby
 * Blink, BlinkFast, BlinkSlow, BlinkTwice, BlinkInverted, BlinkSlowInverted
 * Glowing

### Barometer: Поддержка сенсора BMP280 (барометр + термометр).

Используется библиотека [**BMP280_DEV** by MartinL](https://github.com/MartinL1/BMP280_DEV)

В Config.h необходимо определить пины I2C шины (константы I2C_SDA и I2C_SCL).

Публикуемые MQTT топики:
 * **Sensors/Temperature**: температура (Retained)
 * **Sensors/Pressure**: Давление в мм.рт.ст (Retained)
 * **Sensors/BarometerValid**: Показания сенсора актуальны и действительны (Retained)

### LightMeter: Поддержка сенсора BH1750 (цифровой датчик освещенности)

Используется библиотека [**BH1750** by Christopher Laws](https://github.com/claws/BH1750)

Публикуемые MQTT топики:
 * **Sensors/LightLevel**: текущий уровень освещенности (Retained)
 * **Sensors/LightLevelValid**: Показания сенсора актуальны и действительны (Retained)

В случае, если в функция инициализации модуля вызвана с параметром (true) - модуль отслеживает наступление восхода и заката солнца,
аппроксимируя изменение уровня оствещенности за 30 минут и фиксируя время перехода пороговых значений.

Для нормальной работы трекера необходимо включить синхронизацию времени (**#define TIMEZONE TZ_Europe_Moscow**).
Публикуемые MQTT топики:
 * **Sensors/LightLevelFiltered**: аппроксимация текущего уровеня освещенности по результатам измерений за последние 15 минут (retained, lux)
 * **Sensors/SunriseLevel**: пороговое значение освещенности для определения момента восхода солнца (retained, lux)
 * **Sensors/SunsetLevel**: пороговое значение освещенности для момента заката солнца (retained, lux)
 * **Sensors/Sunrise**: время последнего восхода (HH:MM, retained, можно использовать как значение по умолчанию если устройство по какой-то причине недоступно)
 * **Sensors/Sunset**: время последнего восхода (HH:MM, retained, аналогично предыдущему)
 * **Sensors/DayPhase**: текущее время суток ("Day", "Night" или "Unknown", retained)

Принимает следующие команды, полученные через MQTT:
 * **Sensors/SetSunriseLevel**, задание порогового значения освещенности для восхода (lux)
 * **Sensors/SetSunsetLevel**, задание порогового значения освещенности для заката (lux)


### TAH: Поддержка датчика влажности и температуры DHT22 и аналогичных

Используется библиотека [**DHTesp** by beegee-tokyo](https://github.com/beegee-tokyo/DHTesp)

В конфигурации необходимо определить номер пина, к которому подключен сенсор (константа DHT_Pin)

Публикуемые MQTT топики:
 * **Sensors/Temperature**: Температура (Retained)
 * **Sensors/Humidity**: Влажность воздуха (Retained)
 * **Sensors/AbsHumidity**: Абсолютная влажность, г/м3 (Retained)
 * **Sensors/HeatIndex**: "Ощущаемая температура" (Retained)
 * **Sensors/TAHValid**: Показания сенсоры актуальны и действительны (Retained)

### TAH_HTU21D: Поддержка датчика влажности и температуры GY-213 и аналогичных на базе сенсора HTU21D

Используется библиотека [**SparkFun** HTU21D library](https://github.com/sparkfun/SparkFun_HTU21D_Breakout_Arduino_Library)

Модуль подключается через i2c, поэтому перед его инициализацией небоходим вызов Wire.begin() 
MQTT интерфейс полностью совпадает с модулем TAH.

### PIR: Поддержка нескольких детекторов движения

Детекторы движения подключаются к цифровым входам ESP. Если при регистрации датчика движения указать непустое имя, 
то оно будет публиковаться в MQTT. Кроме того можно определить "комбинированный" детектор движения, реагирующий
на срабатывание любого из зарегистрированных датчиков движения

Публикуемые MQTT топики:
 * **\<PIR1\>/Active**, "1" или "0": обнаружено движение (retained)
 * **\<PIR1\>/Enabled**, "1" или "0": датчик включен и активен (retained)
 * **\<PIR1\>/Timeout**: интервал в секундах, в течение которого датчик будет оставаться активен после обнаружения движения (retained)

 Топики, обрабатываемые модулем:
 * **\<PIR1\>/Enable**: включить датчик движения
 * **\<PIR1\>/Disable**: выключить датчик движения
 * **\<PIR1\>/SetTimeout**, payload=<интервал в секундах>: установить таймаут


